{"version":3,"sources":["webpack://backend/webpack/bootstrap","webpack://backend/external \"require3\"","webpack://backend/./backend/src/common/wechatHelper.js","webpack://backend/./backend/src/common/wechatUtils.js","webpack://backend/./backend/src/main.js","webpack://backend/./backend/src/config/config.js","webpack://backend/./backend/src/config/locales.js","webpack://backend/./backend/src/config/locale/zh-cn.js","webpack://backend/./backend/src/config/errors.js","webpack://backend/./backend/src/config/middlewares.js","webpack://backend/./backend/src/config/middleware/wechat.js","webpack://backend/./backend/src/config/middleware/wechatMini.js","webpack://backend/./backend/src/config/middleware/inWechat.js","webpack://backend/./backend/src/config/middleware/inWechatMini.js","webpack://backend/./backend/src/routes.js","webpack://backend/./backend/src/controller/version.js","webpack://backend/./backend/src/controller/message.js","webpack://backend/external \"crypto\"","webpack://backend/./backend/src/controller/event.js","webpack://backend/./backend/src/controller/jssdk.js","webpack://backend/./backend/src/controller/messageMini.js","webpack://backend/./backend/src/controller/authMini.js","webpack://backend/./backend/src/services.js","webpack://backend/./backend/src/service/version.js","webpack://backend/./backend/src/service/message.js","webpack://backend/./backend/src/service/event.js","webpack://backend/./backend/src/service/jssdk.js","webpack://backend/./backend/src/service/messageMini.js","webpack://backend/./backend/src/service/authMini.js","webpack://backend/./backend/src/models.js","webpack://backend/./backend/src/model/wechatUser.js","webpack://backend/./backend/src/model/auth.js","webpack://backend/./backend/src/meta.js","webpack://backend/./backend/src/passport/auth.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,qC;;;;;;ACAA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B;;AAEA;AACA,0BAA0B,oCAAoC;AAC9D;AACA,yDAAyD,0BAA0B;AACnF;AACA,sDAAsD,0BAA0B;AAChF;AACA;AACA;AACA,iDAAiD,8BAA8B;AAC/E;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,gDAAgD;AACzF;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA,2BAA2B,QAAQ,GAAG,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,0GAA0G,OAAO;AACjH;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,QAAQ;AAC/F;AACA;AACA;AACA;AACA;AACA,uCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACrJA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA,GAAG;AACH,kBAAkB,gEAAgE;AAClF,sCAAsC,oCAAoC;AAC1E;AACA;AACA,KAAK;AACL,GAAG;AACH,YAAY,uDAAuD;AACnE,gCAAgC,4BAA4B;AAC5D,GAAG;AACH;;;;;;;AC1BA,eAAe,mBAAO,CAAC,CAAoB;AAC3C,gBAAgB,mBAAO,CAAC,CAAqB;AAC7C,eAAe,mBAAO,CAAC,CAAoB;AAC3C,oBAAoB,mBAAO,CAAC,CAAyB;;AAErD;;AAEA;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,mBAAmB,mBAAO,CAAC,EAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC9FA;AACA,WAAW,mBAAO,CAAC,CAAmB;AACtC;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;;;;;;;ACJA,eAAe,mBAAO,CAAC,CAAwB;AAC/C,mBAAmB,mBAAO,CAAC,EAA4B;AACvD,iBAAiB,mBAAO,CAAC,EAA0B;AACnD,qBAAqB,mBAAO,CAAC,EAA8B;;AAE3D;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;;AAEA;AACA;;AAEA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK;AACjD;AACA,OAAO;AACP;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,MAAM;AACrD;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;ACnDA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;;AAEA;AACA;;AAEA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA,OAAO;AACP;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA,OAAO;AACP;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA,gBAAgB,mBAAO,CAAC,EAAyB;AACjD,gBAAgB,mBAAO,CAAC,EAAyB;AACjD,cAAc,mBAAO,CAAC,EAAuB;AAC7C,cAAc,mBAAO,CAAC,EAAuB;AAC7C,oBAAoB,mBAAO,CAAC,EAA6B;AACzD,iBAAiB,mBAAO,CAAC,EAA0B;;AAEnD;AACA;AACA;AACA,KAAK,oFAAoF;AACzF,KAAK,kFAAkF;AACvF,KAAK,iFAAiF;AACtF;AACA,KAAK,0FAA0F,QAAQ,gBAAgB,EAAE,EAAE;AAC3H,KAAK,2FAA2F,QAAQ,gBAAgB,EAAE,EAAE;AAC5H;AACA,KAAK,mFAAmF;AACxF;AACA,KAAK,0FAA0F,QAAQ,gBAAgB,EAAE,EAAE;;AAE3H;AACA,KAAK,sGAAsG,QAAQ,gBAAgB,EAAE,EAAE;AACvI,KAAK,uGAAuG,QAAQ,gBAAgB,EAAE,EAAE;AACxI;AACA,KAAK,iGAAiG,QAAQ,gBAAgB,EAAE,EAAE;;AAElI;AACA;AACA;;;;;;;AC7BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA,oBAAoB,mBAAO,CAAC,CAA0B;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yCAAyC;AAC1F;AACA;AACA;AACA;AACA,OAAO;AACP,kDAAkD,yCAAyC;AAC3F;AACA;AACA,iEAAiE,qBAAqB;AACtF;AACA;AACA,SAAS;AACT,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/FA,mC;;;;;;ACAA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACZA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA,oBAAoB,mBAAO,CAAC,CAA0B;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yCAAyC;AAC1F;AACA;AACA;AACA;AACA,OAAO;AACP,kDAAkD,yCAAyC;AAC3F;AACA,kDAAkD,qBAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,cAAc;AACd;;AAEA,6BAA6B,yCAAyC;AACtE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACxEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACbA,gBAAgB,mBAAO,CAAC,EAAsB;AAC9C,gBAAgB,mBAAO,CAAC,EAAsB;AAC9C,cAAc,mBAAO,CAAC,EAAoB;AAC1C,cAAc,mBAAO,CAAC,EAAoB;AAC1C,oBAAoB,mBAAO,CAAC,EAA0B;AACtD,iBAAiB,mBAAO,CAAC,EAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACjDA,uBAAuB,mBAAO,CAAC,CAA2B;;AAE1D;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,2CAA2C,wCAAwC;AACnF,SAAS;AACT,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;AACA,2DAA2D,SAAS;AACpE;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACxEA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;;;;;;AC1BA;;AAEA;;AAEA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACnBA;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,OAAO;AACP;AACA;;AAEA;AACA;;;;;;;ACfA,uBAAuB,mBAAO,CAAC,CAA2B;;AAE1D;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,6BAA6B;AACtE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACnDA,mBAAmB,mBAAO,CAAC,EAAuB;AAClD,aAAa,mBAAO,CAAC,EAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA,kBAAkB,iCAAiC,wBAAwB,EAAE;AAC7E;AACA;AACA;AACA;;;;;;;ACPA;;AAEA;;AAEA;AACA,kBAAkB,2BAA2B,uBAAuB,EAAE;AACtE;;AAEA;;AAEA;AACA;;;;;;;ACXA,eAAe,mBAAO,CAAC,EAAoB;;AAE3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;ACnCA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA,uBAAuB,mBAAO,CAAC,CAA2B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB,WAAW;AACX;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc;AACd;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc;AACd,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,sBAAsB,wBAAwB,EAAE;AAC/D,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA","file":"backend.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"require3\");","const require3 = require('require3');\nconst bb = require3('bluebird');\nconst extend = require3('extend2');\n\nmodule.exports = function(ctx) {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class WechatHelper {\n\n    getSceneInfo(scene) {\n      if (scene === 1) return { authProvider: 'wechat' };\n      if (scene === 2) return { authProvider: 'wechatMini' };\n    }\n\n    // scene: 1/wechat 2/wechatMini\n    async verifyAuthUser({ scene, openid, userInfo, cbVerify }) {\n      // ensure wechat user\n      const userWechatId = await this._ensureWechatUser({ scene, openid, userInfo });\n      // ensure auth user\n      const profileUser = await this._ensureAuthUser({ scene, openid, userInfo });\n      // verify\n      let verifyUser;\n      if (!cbVerify) {\n        verifyUser = await ctx.meta.user.verify({ state: 'login', profileUser });\n        await ctx.login(verifyUser);\n      } else {\n        verifyUser = await bb.fromCallback(cb => {\n          cbVerify(profileUser, cb);\n        });\n      }\n      // update wechat userId\n      await ctx.model.wechatUser.update({ id: userWechatId, userId: verifyUser.agent.id });\n      // ok\n      return verifyUser;\n    }\n\n    async _ensureWechatUser({ scene, openid, userInfo }) {\n      let userWechatId;\n      // wechat user\n      let userWechat = await ctx.model.wechatUser.get({ openid });\n      const exists = !!userWechat;\n      if (!userWechat) {\n        userWechat = {};\n      } else {\n        userWechatId = userWechat.id;\n        delete userWechat.createdAt;\n        delete userWechat.updatedAt;\n        delete userWechat.deleted;\n        delete userWechat.iid;\n        delete userWechat.userId;\n      }\n      // check fields\n      let needUpdate = false;\n      const fields = [ 'scene', 'openid', 'unionid', 'nickname', 'subscribe', 'sex', 'language', 'city', 'province', 'country', 'headimgurl', 'subscribe_time', 'remark', 'groupid', 'subscribe_scene', 'qr_scene', 'qr_scene_str' ];\n      userInfo.scene = scene;\n      for (const field of fields) {\n        if (userInfo[field] === undefined || userInfo[field] === userWechat[field]) {\n          delete userWechat[field];\n        } else {\n          userWechat[field] = userInfo[field];\n          needUpdate = true;\n        }\n      }\n      // update\n      if (needUpdate) {\n        if (!exists) {\n          const res = await ctx.model.wechatUser.insert(userWechat);\n          userWechatId = res.insertId;\n        } else {\n          await ctx.model.wechatUser.update(userWechat);\n        }\n      }\n      // ok\n      return userWechatId;\n    }\n\n    // profileId : unionid:openid\n    async _ensureAuthUser({ scene, openid, userInfo }) {\n      const sceneInfo = this.getSceneInfo(scene);\n      const unionid = userInfo.unionid || '';\n      const profileId = `${unionid}:${openid}`;\n      const profileUser = {\n        module: moduleInfo.relativeName,\n        provider: sceneInfo.authProvider,\n        profileId,\n        profile: {\n          id: profileId,\n          userName: userInfo.nickname,\n          realName: userInfo.nickname,\n          avatar: userInfo.headimgurl,\n          profile: userInfo,\n        },\n      };\n      // provider\n      const providerItem = await ctx.meta.user.getAuthProvider({\n        module: moduleInfo.relativeName,\n        providerName: sceneInfo.authProvider,\n      });\n      // check auth\n      let authId;\n      let authUserId;\n      const authItems = await ctx.model.query(\n        `select * from aAuth a where a.deleted=0 and a.iid=? and a.providerId=? and a.profileId like '%:${openid}'`,\n        [ ctx.instance.id, providerItem.id ]\n      );\n      const authItem = authItems[0];\n      if (!authItem) {\n        // always set avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        delete _profile.avatar;\n        // insert auth\n        const res = await ctx.model.auth.insert({\n          providerId: providerItem.id,\n          profileId,\n          profile: JSON.stringify(_profile),\n        });\n        authId = res.insertId;\n      } else {\n        // hold old avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        const _profileOld = JSON.parse(authItem.profile);\n        _profile.avatar = _profileOld.avatar;\n        // always update\n        await ctx.model.auth.update({\n          id: authItem.id,\n          profileId,\n          profile: JSON.stringify(_profile),\n        });\n        authId = authItem.id;\n        authUserId = authItem.userId;\n      }\n      // check if has userId for unionid\n      if (unionid) {\n        const _authOthers = await ctx.model.query(\n          `select * from aAuth a where a.deleted=0 and a.iid=? and a.profileId like '${unionid}:%' and a.id<>?`,\n          [ ctx.instance.id, authId ]\n        );\n        const _authOther = _authOthers[0];\n        if (_authOther && _authOther.userId !== authUserId) {\n          // update userId for this auth\n          await ctx.model.auth.update({ id: authId, userId: _authOther.userId });\n        }\n      }\n      // ready\n      return profileUser;\n    }\n\n  }\n\n  return WechatHelper;\n};\n","const crypto = require('crypto');\nconst require3 = require('require3');\nconst bb = require3('bluebird');\nconst xml2js = require3('xml2js');\n\nmodule.exports = {\n  createNonceStr() {\n    return Math.random().toString(36).substr(2, 15);\n  },\n  createTimestamp() {\n    return '' + Math.floor(Date.now() / 1000);\n  },\n  calcSignature({ options, join = '', hash = 'sha1' }) {\n    const hashsum = crypto.createHash(hash);\n    hashsum.update(options.join(join));\n    return hashsum.digest('hex');\n  },\n  async parseXML({ xml, trim = true, explicitArray = false, explicitRoot = false }) {\n    const parser = new xml2js.Parser({ trim, explicitArray, explicitRoot });\n    return await bb.fromCallback(cb => {\n      parser.parseString(xml, cb);\n    });\n  },\n  buildXML({ xml, cdata = true, headless = true, rootName = 'xml' }) {\n    return (new xml2js.Builder({ cdata, headless, rootName })).buildObject(xml);\n  },\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\nconst middlewares = require('./config/middlewares.js');\n\nmodule.exports = app => {\n\n  // routes\n  const routes = require('./routes.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    routes,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    middlewares,\n    meta,\n  };\n\n};\n","\nconst jsApiList = [\n  'checkJsApi',\n  'updateAppMessageShareData',\n  'updateTimelineShareData',\n  'onMenuShareWeibo',\n  // 'onMenuShareTimeline',\n  // 'onMenuShareAppMessage',\n  // 'onMenuShareQQ',\n  // 'onMenuShareQZone',\n  'hideMenuItems',\n  'showMenuItems',\n  'hideAllNonBaseMenuItem',\n  'showAllNonBaseMenuItem',\n  'translateVoice',\n  'startRecord',\n  'stopRecord',\n  'onRecordEnd',\n  'playVoice',\n  'pauseVoice',\n  'stopVoice',\n  'uploadVoice',\n  'downloadVoice',\n  'chooseImage',\n  'previewImage',\n  'uploadImage',\n  'downloadImage',\n  'getNetworkType',\n  'openLocation',\n  'getLocation',\n  'hideOptionMenu',\n  'showOptionMenu',\n  'closeWindow',\n  'scanQRCode',\n  'chooseWXPay',\n  'openProductSpecificView',\n  'addCard',\n  'chooseCard',\n  'openCard',\n];\n\nmodule.exports = appInfo => {\n  const config = {};\n\n  // middlewares\n  config.middlewares = {\n    wechat: {\n      global: false,\n      dependencies: 'instance',\n    },\n    wechatMini: {\n      global: false,\n      dependencies: 'instance',\n    },\n    inWechat: {\n      global: false,\n      dependencies: 'instance',\n    },\n    inWechatMini: {\n      global: false,\n      dependencies: 'instance',\n    },\n  };\n\n  // account\n  config.account = {};\n\n  // account.public\n  config.account.public = {\n    appID: '',\n    appSecret: '',\n    token: appInfo.name,\n    encodingAESKey: '',\n    message: {\n      reply: {\n        default: 'You are welcome!',\n        subscribe: 'You are subscribed!',\n      },\n    },\n    jssdk: {\n      debug: false,\n      jsApiList,\n    },\n  };\n\n  // account.mini\n  config.account.mini = {\n    appID: '',\n    appSecret: '',\n    token: appInfo.name,\n    encodingAESKey: '',\n  };\n\n  return config;\n};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = {\n  'Wechat Public': '微信公众号',\n  'Wechat Miniprogram': '微信小程序',\n  'Not In Wechat': '不在微信内部',\n  'Not In Wechat Miniprogram': '不在微信小程序内部',\n};\n","// error code should start from 1001\nmodule.exports = {\n  1001: 'Not In Wechat',\n  1002: 'Not In Wechat Miniprogram',\n};\n","const wechat = require('./middleware/wechat.js');\nconst wechatMini = require('./middleware/wechatMini.js');\nconst inWechat = require('./middleware/inWechat.js');\nconst inWechatMini = require('./middleware/inWechatMini.js');\n\nmodule.exports = {\n  wechat,\n  wechatMini,\n  inWechat,\n  inWechatMini,\n};\n","const require3 = require('require3');\nconst WechatAPI = require3('@zhennann/co-wechat-api');\nconst WECHAT = Symbol('CTX#WECHAT');\n\nmodule.exports = (options, app) => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n\n  function _createWechatApi({ ctx }) {\n    // config\n    const config = ctx.config.module(moduleInfo.relativeName).account.public;\n    // api\n    const api = new WechatAPI(config.appID, config.appSecret,\n      async function() {\n        const cacheKey = 'wechat-token';\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function(token) {\n        const cacheKey = 'wechat-token';\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n      }\n    );\n    // registerTicketHandle\n    api.registerTicketHandle(\n      async function(type) {\n        const cacheKey = `wechat-jsticket:${type}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function(type, token) {\n        const cacheKey = `wechat-jsticket:${type}`;\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n      }\n    );\n    // ready\n    return api;\n  }\n\n  return async function wechat(ctx, next) {\n    ctx.meta = ctx.meta || {};\n    Object.defineProperty(ctx.meta, 'wechat', {\n      get() {\n        if (ctx.meta[WECHAT] === undefined) {\n          ctx.meta[WECHAT] = _createWechatApi({ ctx });\n        }\n        return ctx.meta[WECHAT];\n      },\n    });\n\n    // next\n    await next();\n  };\n\n};\n\n","const require3 = require('require3');\nconst WechatAPI = require3('@zhennann/co-wechat-api');\nconst WECHATMINI = Symbol('CTX#WECHATMINI');\n\nmodule.exports = (options, app) => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n\n  function _createWechatMiniApi({ ctx }) {\n    // config\n    const config = ctx.config.module(moduleInfo.relativeName).account.mini;\n    // api\n    const api = new WechatAPI(config.appID, config.appSecret,\n      async function() {\n        const cacheKey = 'wechatmini-token';\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function(token) {\n        const cacheKey = 'wechatmini-token';\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n      }\n    );\n    // registerTicketHandle\n    api.registerTicketHandle(\n      async function(type) {\n        const cacheKey = `wechatmini-jsticket:${type}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function(type, token) {\n        const cacheKey = `wechatmini-jsticket:${type}`;\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n      }\n    );\n    // registerSessionKeyHandle\n    api.registerSessionKeyHandle(\n      async function() {\n        const cacheKey = `wechatmini-sessionKey:${ctx.user.agent.id}`;\n        return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n      },\n      async function(sessionKey) {\n        const cacheKey = `wechatmini-sessionKey:${ctx.user.agent.id}`;\n        await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, sessionKey);\n      }\n    );\n    // ready\n    return api;\n  }\n\n  return async function wechatMini(ctx, next) {\n    ctx.meta = ctx.meta || {};\n    Object.defineProperty(ctx.meta, 'wechatMini', {\n      get() {\n        if (ctx.meta[WECHATMINI] === undefined) {\n          ctx.meta[WECHATMINI] = _createWechatMiniApi({ ctx });\n        }\n        return ctx.meta[WECHATMINI];\n      },\n    });\n\n    // next\n    await next();\n  };\n\n};\n\n","module.exports = (options, app) => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  return async function inWechat(ctx, next) {\n    const provider = ctx.user && ctx.user.provider;\n    const ok = (provider && provider.module === moduleInfo.relativeName && provider.providerName === 'wechat');\n    if (!ok) ctx.throw.module(moduleInfo.relativeName, 1001);\n    // next\n    await next();\n  };\n};\n","module.exports = (options, app) => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  return async function inWechatMini(ctx, next) {\n    const provider = ctx.user && ctx.user.provider;\n    const ok = (provider && provider.module === moduleInfo.relativeName && provider.providerName === 'wechatMini');\n    if (!ok) ctx.throw.module(moduleInfo.relativeName, 1002);\n    // next\n    await next();\n  };\n};\n","const version = require('./controller/version.js');\nconst message = require('./controller/message.js');\nconst event = require('./controller/event.js');\nconst jssdk = require('./controller/jssdk.js');\nconst messageMini = require('./controller/messageMini.js');\nconst authMini = require('./controller/authMini.js');\n\nmodule.exports = app => {\n  const routes = [\n    // version\n    { method: 'post', path: 'version/update', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/init', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/test', controller: version, middlewares: 'test' },\n    // message\n    { method: 'get', path: 'message/index', controller: message, middlewares: 'wechat', meta: { auth: { enable: false } } },\n    { method: 'post', path: 'message/index', controller: message, middlewares: 'wechat', meta: { auth: { enable: false } } },\n    // jsapi\n    { method: 'post', path: 'jssdk/jsconfig', controller: jssdk, middlewares: 'wechat' },\n    // event\n    { method: 'post', path: 'event/loginInfo', controller: event, middlewares: 'inner', meta: { auth: { enable: false } } },\n\n    // messageMini\n    { method: 'get', path: 'messageMini/index', controller: messageMini, middlewares: 'wechatMini', meta: { auth: { enable: false } } },\n    { method: 'post', path: 'messageMini/index', controller: messageMini, middlewares: 'wechatMini', meta: { auth: { enable: false } } },\n    // authMini\n    { method: 'post', path: 'authMini/login', controller: authMini, middlewares: 'wechatMini', meta: { auth: { enable: false } } },\n\n  ];\n  return routes;\n};\n","module.exports = app => {\n  class VersionController extends app.Controller {\n\n    async update() {\n      await this.service.version.update(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async init() {\n      await this.service.version.init(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async test() {\n      await this.service.version.test(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n  }\n  return VersionController;\n};\n","const require3 = require('require3');\nconst WechatCrypto = require3('wechat-crypto');\nconst wechatUtils = require('../common/wechatUtils.js');\n\nmodule.exports = app => {\n  class MessageController extends app.Controller {\n\n    async index() {\n      // query\n      const query = this.ctx.query;\n      // config\n      const config = this.ctx.config.account.public;\n      // encrypted\n      const encrypted = query.encrypt_type === 'aes';\n      // wechat crypto\n      const wechatCrypto = encrypted ? new WechatCrypto(config.token, config.encodingAESKey, config.appID) : null;\n      // parse\n      let messageIn;\n      if (this.ctx.method === 'GET') {\n        messageIn = await this._parseMessageGet({ query, config, encrypted, wechatCrypto });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = messageIn.echostr;\n      } else {\n        messageIn = await this._parseMessagePost({ query, config, encrypted, wechatCrypto });\n        // handle\n        let resXML;\n        const messageOut = await this.ctx.service.message.index({ message: messageIn });\n        if (!messageOut) {\n          resXML = '';\n        } else {\n          resXML = wechatUtils.buildXML({ xml: messageOut });\n          if (encrypted) {\n            const wrap = {};\n            wrap.Encrypt = wechatCrypto.encrypt(resXML);\n            wrap.TimeStamp = wechatUtils.createTimestamp();\n            wrap.Nonce = wechatUtils.createNonceStr();\n            wrap.MsgSignature = wechatCrypto.getSignature(wrap.TimeStamp, wrap.Nonce, wrap.Encrypt);\n            resXML = wechatUtils.buildXML({ xml: wrap });\n          }\n        }\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/xml';\n        this.ctx.body = resXML;\n      }\n    }\n\n    async _parseMessageGet({ query, config, encrypted, wechatCrypto }) {\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, query.echostr);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [ config.token, query.timestamp, query.nonce ].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(query.echostr);\n        return { echostr: res.message };\n      }\n      return { echostr: query.echostr };\n    }\n\n    async _parseMessagePost({ query, config, encrypted, wechatCrypto }) {\n      // xml raw\n      let xmlRaw;\n      if (typeof this.ctx.request.body === 'string') {\n        xmlRaw = this.ctx.request.body;\n      } else {\n        const payload = await this.ctx.getPayload();\n        xmlRaw = payload.toString();\n      }\n      // parse xml\n      let xml = await wechatUtils.parseXML({ xml: xmlRaw });\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, xml.Encrypt);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [ config.token, query.timestamp, query.nonce ].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(xml.Encrypt);\n        xml = await wechatUtils.parseXML({ xml: res.message });\n      }\n      return xml;\n    }\n\n  }\n  return MessageController;\n};\n\n","module.exports = require(\"crypto\");","module.exports = app => {\n  class EventController extends app.Controller {\n\n    async loginInfo() {\n      const res = await this.service.event.loginInfo({\n        event: this.ctx.request.body.event,\n        data: this.ctx.request.body.data,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return EventController;\n};\n","module.exports = app => {\n  class JSSDKController extends app.Controller {\n\n    async jsconfig() {\n      const res = await this.service.jssdk.jsconfig({\n        url: this.ctx.request.body.url,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return JSSDKController;\n};\n","const require3 = require('require3');\nconst WechatCrypto = require3('wechat-crypto');\nconst wechatUtils = require('../common/wechatUtils.js');\n\nmodule.exports = app => {\n  class MessageMiniController extends app.Controller {\n\n    async index() {\n      // query\n      const query = this.ctx.query;\n      // config\n      const config = this.ctx.config.account.mini;\n      // encrypted\n      const encrypted = query.encrypt_type === 'aes';\n      // wechat crypto\n      const wechatCrypto = encrypted ? new WechatCrypto(config.token, config.encodingAESKey, config.appID) : null;\n      // parse\n      let messageIn;\n      if (this.ctx.method === 'GET') {\n        messageIn = await this._parseMessageGet({ query, config, encrypted, wechatCrypto });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = messageIn.echostr;\n      } else {\n        messageIn = await this._parseMessagePost({ query, config, encrypted, wechatCrypto });\n        // handle\n        await this.ctx.service.messageMini.index({ message: messageIn });\n        // ok\n        this.ctx.status = 200;\n        this.ctx.type = 'text/plain';\n        this.ctx.body = '';\n      }\n    }\n\n    async _parseMessageGet({ query, config, encrypted, wechatCrypto }) {\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, query.echostr);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [ config.token, query.timestamp, query.nonce ].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(query.echostr);\n        return { echostr: res.message };\n      }\n      return { echostr: query.echostr };\n    }\n\n    async _parseMessagePost({ query, config, encrypted, wechatCrypto }) {\n      let messageIn = this.ctx.request.body;\n      // check if valid\n      let valid = false;\n      if (encrypted) {\n        valid = query.msg_signature === wechatCrypto.getSignature(query.timestamp, query.nonce, messageIn.Encrypt);\n      } else {\n        valid = query.signature === wechatUtils.calcSignature({ options: [ config.token, query.timestamp, query.nonce ].sort() });\n      }\n      if (!valid) this.ctx.throw(401);\n      // decrypt\n      if (encrypted) {\n        const res = wechatCrypto.decrypt(messageIn.Encrypt);\n        messageIn = JSON.parse(res.message);\n      }\n      return messageIn;\n    }\n\n  }\n  return MessageMiniController;\n};\n\n","module.exports = app => {\n  class AuthMiniController extends app.Controller {\n\n    async login() {\n      const res = await this.service.authMini.login({\n        code: this.ctx.request.body.code,\n        detail: this.ctx.request.body.detail,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return AuthMiniController;\n};\n","const version = require('./service/version.js');\nconst message = require('./service/message.js');\nconst event = require('./service/event.js');\nconst jssdk = require('./service/jssdk.js');\nconst messageMini = require('./service/messageMini.js');\nconst authMini = require('./service/authMini.js');\n\nmodule.exports = app => {\n  const services = {\n    version,\n    message,\n    event,\n    jssdk,\n    messageMini,\n    authMini,\n  };\n  return services;\n};\n","module.exports = app => {\n\n  class Version extends app.Service {\n\n    async update(options) {\n      if (options.version === 1) {\n\n        // create table: aWechatUser\n        const sql = `\n          CREATE TABLE aWechatUser (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            scene int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            openid varchar(255) DEFAULT NULL,\n            unionid varchar(255) DEFAULT NULL,\n            nickname varchar(50) DEFAULT NULL,\n            subscribe int(11) DEFAULT '0',\n            sex int(11) DEFAULT '0',\n            language varchar(50) DEFAULT NULL,\n            city varchar(50) DEFAULT NULL,\n            province varchar(50) DEFAULT NULL,\n            country varchar(50) DEFAULT NULL,\n            headimgurl varchar(255) DEFAULT NULL,\n            subscribe_time int(11) DEFAULT '0',\n            remark varchar(255) DEFAULT NULL,\n            groupid int(11) DEFAULT '0',\n            subscribe_scene varchar(50) DEFAULT NULL,\n            qr_scene int(11) DEFAULT '0',\n            qr_scene_str varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n      }\n    }\n\n    async init(options) {\n    }\n\n    async test() {\n    }\n\n  }\n\n  return Version;\n};\n","const WechatHelperFn = require('../common/wechatHelper.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Message extends app.Service {\n\n    async index({ message }) {\n      let res;\n      // event: subscribe\n      if (message.MsgType === 'event') {\n        if (message.Event === 'subscribe') {\n          res = await this._subscribeUser({ openid: message.FromUserName, message });\n        } else if (message.Event === 'unsubscribe') {\n          res = await this._unsubscribeUser({ openid: message.FromUserName, message });\n        }\n      }\n      // raise event\n      const res2 = await this.ctx.meta.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'wechatMessage',\n        data: { message },\n      });\n      if (res2) res = res2;\n      // check if ready\n      if (res) return res;\n      // default reply\n      return {\n        ToUserName: message.FromUserName,\n        FromUserName: message.ToUserName,\n        CreateTime: new Date().getTime(),\n        MsgType: 'text',\n        Content: this.ctx.config.account.public.message.reply.default,\n      };\n    }\n\n    async _subscribeUser({ openid, message }) {\n      // user info\n      const userInfo = await this.ctx.meta.wechat.getUser({ openid });\n      // verify auth user\n      const wechatHelper = new (WechatHelperFn(this.ctx))();\n      await wechatHelper.verifyAuthUser({ scene: 1, openid, userInfo });\n      // ok\n      return {\n        ToUserName: message.FromUserName,\n        FromUserName: message.ToUserName,\n        CreateTime: new Date().getTime(),\n        MsgType: 'text',\n        Content: this.ctx.config.account.public.message.reply.subscribe,\n      };\n    }\n\n    async _unsubscribeUser({ openid, message }) {\n      // wechat user\n      const userWechat = await this.ctx.model.wechatUser.get({ openid });\n      if (userWechat) {\n        await this.ctx.model.wechatUser.update({\n          id: userWechat.id, subscribe: 0,\n        });\n      }\n      // ok\n      return {\n        ToUserName: message.FromUserName,\n        FromUserName: message.ToUserName,\n        CreateTime: new Date().getTime(),\n        MsgType: 'text',\n        Content: '',\n      };\n    }\n\n  }\n\n  return Message;\n};\n","const require3 = require('require3');\nconst extend = require3('extend2');\n\nmodule.exports = app => {\n\n  class Event extends app.Service {\n\n    async loginInfo({ /* event,*/ data }) {\n      const info = data.info;\n      const provider = info.user && info.user.provider;\n      if (provider && provider.module === 'a-wechat' && provider.providerName === 'wechat') {\n        info.config = extend(true, info.config, {\n          modules: {\n            'a-base': {\n              account: {\n                needActivation: false,\n              },\n            },\n          },\n        });\n      }\n    }\n\n  }\n\n  return Event;\n};\n","module.exports = app => {\n\n  class JSSDK extends app.Service {\n\n    async jsconfig({ url }) {\n      // config\n      const config = this.ctx.config.account.public;\n      // params\n      const params = {\n        debug: config.jssdk.debug,\n        jsApiList: config.jssdk.jsApiList,\n        url,\n      };\n      return await this.ctx.meta.wechat.getJsConfig(params);\n    }\n\n  }\n\n  return JSSDK;\n};\n","module.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Message extends app.Service {\n\n    async index({ message }) {\n      // raise event\n      await this.ctx.meta.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'wechatMessageMini',\n        data: { message },\n      });\n    }\n  }\n\n  return Message;\n};\n","const WechatHelperFn = require('../common/wechatHelper.js');\n\nmodule.exports = app => {\n\n  class AuthMini extends app.Service {\n\n    async login({ code, detail }) {\n      let session_key;\n      let openid;\n      let unionid;\n      if (code) {\n        // code2Session\n        const res = await this.ctx.meta.wechatMini.code2Session(code);\n        session_key = res.session_key;\n        openid = res.openid;\n        unionid = res.unionid;\n      } else {\n        // from cache\n        session_key = await this.ctx.meta.wechatMini.getSessionKey();\n      }\n      // openid/unionid\n      if ((!openid || !unionid) && detail && detail.encryptedData) {\n        const res = await this.ctx.meta.wechatMini.decryptMini(detail.encryptedData, detail.iv, session_key);\n        openid = res.openId;\n        unionid = res.unionId;\n      }\n      // check openid\n      if (!openid) this.ctx.throw(403);\n      // userInfo\n      const userInfo = { openid, unionid };\n      if (detail && detail.userInfo) {\n        userInfo.nickname = detail.userInfo.nickName;\n        userInfo.sex = detail.userInfo.gender;\n        userInfo.language = detail.userInfo.language;\n        userInfo.city = detail.userInfo.city;\n        userInfo.province = detail.userInfo.province;\n        userInfo.country = detail.userInfo.country;\n        userInfo.headimgurl = detail.userInfo.avatarUrl;\n      }\n      // verify\n      const wechatHelper = new (WechatHelperFn(this.ctx))();\n      await wechatHelper.verifyAuthUser({ scene: 2, openid, userInfo });\n      // save session_key, because ctx.user maybe changed\n      await this.ctx.meta.wechatMini.saveSessionKey(session_key);\n      // echo\n      return await this.ctx.meta.auth.echo();\n    }\n\n  }\n\n  return AuthMini;\n};\n","const wechatUser = require('./model/wechatUser.js');\nconst auth = require('./model/auth.js');\n\nmodule.exports = app => {\n  const models = {\n    wechatUser,\n    auth,\n  };\n  return models;\n};\n","module.exports = app => {\n  class WechatUser extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aWechatUser', options: { disableDeleted: false } });\n    }\n  }\n  return WechatUser;\n};\n","module.exports = app => {\n\n  class Auth extends app.meta.Model {\n\n    constructor(ctx) {\n      super(ctx, { table: 'aAuth', options: { disableDeleted: true } });\n    }\n\n  }\n\n  return Auth;\n};\n","const authFn = require('./passport/auth.js');\n\nmodule.exports = app => {\n  // const schemas = require('./config/validation/schemas.js')(app);\n  const meta = {\n    base: {\n      atoms: {\n      },\n      functions: {\n      },\n    },\n    validation: {\n      validators: {\n      },\n      keywords: {},\n      schemas: {\n      },\n    },\n    event: {\n      declarations: {\n        wechatMessage: 'Wechat Message',\n        wechatMessageMini: 'Miniprogram Message',\n      },\n      implementations: {\n        'a-base:loginInfo': 'event/loginInfo',\n      },\n    },\n    index: {\n      indexes: {\n        aWechatUser: 'createdAt,updatedAt,openid,unionid',\n      },\n    },\n    auth: authFn(app),\n  };\n  return meta;\n};\n","const require3 = require('require3');\nconst strategy = require3('@zhennann/passport-wechat').Strategy;\nconst WechatHelperFn = require('../common/wechatHelper.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  const providerName = 'wechat';\n  const providerNameMini = 'wechatMini';\n  return {\n    providers: {\n      [providerName]: {\n        meta: {\n          title: 'Wechat Public',\n          mode: 'redirect',\n          component: 'button',\n        },\n        config: {\n          appID: '',\n          appSecret: '',\n          client: 'wechat',\n          scope: 'snsapi_userinfo',\n        },\n        configFunctions: {\n          getConfig(ctx) {\n            const config = ctx.config.module(moduleInfo.relativeName).account.public;\n            return { appID: config.appID, appSecret: config.appSecret };\n          },\n          // getToken(ctx, openid, cb) {\n          //   const name = `wechat-public:${openid}`;\n          //   ctx.cache.db.module(moduleInfo.relativeName).get(name)\n          //     .then(token => {\n          //       cb(null, token);\n          //     })\n          //     .catch(cb);\n          // },\n          // saveToken(ctx, openid, token, cb) {\n          //   const name = `wechat-public:${openid}`;\n          //   ctx.cache.db.module(moduleInfo.relativeName).set(name, token, (token.expires_in - 10) * 1000)\n          //     .then(() => {\n          //       cb(null);\n          //     })\n          //     .catch(cb);\n          // },\n        },\n        handler: app => {\n          return {\n            strategy,\n            callback: (req, accessToken, refreshToken, userInfo, expires_in, done) => {\n              const wechatHelper = new (WechatHelperFn(req.ctx))();\n              wechatHelper.verifyAuthUser({\n                scene: 1,\n                openid: userInfo.openid,\n                userInfo,\n                cbVerify: (profileUser, cb) => {\n                  app.passport.doVerify(req, profileUser, cb);\n                },\n              }).then(verifyUser => { done(null, verifyUser); }).catch(done);\n            },\n          };\n        },\n      },\n      [providerNameMini]: {\n        meta: {\n          title: 'Wechat Miniprogram',\n          mode: 'direct',\n        },\n        config: {\n        },\n        handler: null,\n      },\n    },\n  };\n};\n"],"sourceRoot":""}