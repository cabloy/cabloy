{"version":3,"file":"backend.js","mappings":";;;;;;AAAA,aAAa,mBAAO,CAAC,EAAM;AAC3B,WAAW,mBAAO,CAAC,GAAI;AACvB,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,IAAI;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA,WAAW;AACX;AACA;AACA,uCAAuC;AACvC,QAAQ;AACR;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA,yCAAyC,OAAO,qBAAqB,UAAU,kBAAkB;AACjG;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE,QAAQ;AACR;AACA;AACA;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB,GAAG,IAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,yBAAyB;AAC3D;;AAEA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,qDAAqD,GAAG,sBAAsB;AAC9G;AACA;AACA,6CAA6C,UAAU,EAAE,aAAa;;AAEtE;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE,UAAU;AACV,wDAAwD,yCAAyC;AACjG;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA,wCAAwC,uBAAuB;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,yCAAyC,OAAO,QAAQ,UAAU,eAAe,QAAQ;AACzF;;AAEA;AACA,gDAAgD,yCAAyC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yCAAyC;AAC9D;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,oBAAoB;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,YAAY;AACnD,QAAQ;AACR;AACA;;AAEA;AACA,wDAAwD,cAAc,GAAG,SAAS,EAAE,aAAa;;AAEjG;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB,kCAAkC,EAAE,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD,QAAQ;AACR,0CAA0C,YAAY;AACtD;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC,wCAAwC,oBAAoB;AAC5D;;AAEA;AACA;AACA,iDAAiD,cAAc,EAAE,aAAa;AAC9E;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;;AAEA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc,GAAG,aAAa,GAAG,cAAc;AACzE,sDAAsD,cAAc,GAAG,SAAS,EAAE,aAAa;;AAE/F;AACA;;AAEA;AACA;;AAEA,qDAAqD,cAAc,GAAG,cAAc,EAAE,aAAa;;AAEnG;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA,iCAAiC,oBAAoB;AACrD;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;;AAEA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,gCAAgC,yCAAyC;AACzE;AACA;AACA,sCAAsC,gCAAgC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,qBAAqB,mCAAmC;AACxD,6CAA6C,WAAW,EAAE,wCAAwC;AAClG;AACA,iBAAiB,IAAI,UAAU,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACzDA,uBAAuB,mBAAO,CAAC,GAA2B;AAC1D,iBAAiB,mBAAO,CAAC,GAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;;;;;;;;ACJA;AACA;;;;;;;;ACDA;AACA;AACA;;;;;;;;ACFA;AACA,WAAW,mBAAO,CAAC,EAAmB;AACtC;;;;;;;;ACFA;AACA;AACA;AACA;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;;;;;;ACnEA,aAAa,mBAAO,CAAC,GAAsB;;AAE3C;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA,eAAe,mBAAO,CAAC,EAAoB;AAC3C,gBAAgB,mBAAO,CAAC,EAAqB;AAC7C,eAAe,mBAAO,CAAC,GAAoB;;AAE3C;AACA;AACA,gBAAgB,mBAAO,CAAC,GAAY;AACpC;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,sBAAsB,mBAAO,CAAC,EAAkB;AAChD;AACA,mBAAmB,mBAAO,CAAC,GAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,GAAa;AACtC;AACA,eAAe,mBAAO,CAAC,GAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7BA;AACA,kBAAkB,mBAAO,CAAC,GAAgC;AAC1D;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA,oBAAoB;AACpB,kBAAkB;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;;ACnBA;AACA;AACA;AACA,mBAAmB,2BAA2B,yBAAyB;AACvE;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA,mBAAmB,+BAA+B,yBAAyB;AAC3E;AACA;AACA;AACA;;;;;;;;ACPA,aAAa,mBAAO,CAAC,GAAiB;AACtC,iBAAiB,mBAAO,CAAC,EAAqB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA,MAAM,iEAAiE,QAAQ,gBAAgB;AAC/F,MAAM,wEAAwE,QAAQ,gBAAgB;AACtG,MAAM,0FAA0F;AAChG,MAAM,uDAAuD;AAC7D,MAAM,yDAAyD;AAC/D,MAAM,qFAAqF;AAC3F,MAAM,sDAAsD;AAC5D;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,4CAA4C,0BAA0B;AACtE;;AAEA;AACA,iBAAiB,oBAAoB;AACrC,6CAA6C,oBAAoB;AACjE;;AAEA,mBAAmB,cAAc;AACjC,+CAA+C,cAAc;AAC7D;;AAEA,mBAAmB,oBAAoB;AACvC,+CAA+C,oBAAoB;AACnE;;AAEA,mBAAmB,MAAM;AACzB,+CAA+C,MAAM;AACrD;;AAEA,0BAA0B,YAAY;AACtC,sDAAsD,YAAY;AAClE;;AAEA,qBAAqB,yCAAyC;AAC9D,iDAAiD,yCAAyC;AAC1F;;AAEA;AACA,qBAAqB,YAAY;AACjC,iDAAiD,YAAY;AAC7D;;AAEA,4BAA4B,YAAY;AACxC,wDAAwD,YAAY;AACpE;;AAEA,8BAA8B,YAAY;AAC1C,0DAA0D,YAAY;AACtE;AACA;;AAEA;AACA;;;;;;;;AC/CA,aAAa,mBAAO,CAAC,GAAmB;;AAExC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://egg-born-module-a-file/./backend/src/bean/bean.file.js","webpack://egg-born-module-a-file/./backend/src/bean/version.manager.js","webpack://egg-born-module-a-file/./backend/src/beans.js","webpack://egg-born-module-a-file/./backend/src/config/config.js","webpack://egg-born-module-a-file/./backend/src/config/errors.js","webpack://egg-born-module-a-file/./backend/src/config/locale/zh-cn.js","webpack://egg-born-module-a-file/./backend/src/config/locales.js","webpack://egg-born-module-a-file/./backend/src/config/validation/schemas.js","webpack://egg-born-module-a-file/./backend/src/controller/file.js","webpack://egg-born-module-a-file/./backend/src/controllers.js","webpack://egg-born-module-a-file/./backend/src/main.js","webpack://egg-born-module-a-file/./backend/src/meta.js","webpack://egg-born-module-a-file/./backend/src/model/file.js","webpack://egg-born-module-a-file/./backend/src/model/fileView.js","webpack://egg-born-module-a-file/./backend/src/models.js","webpack://egg-born-module-a-file/./backend/src/routes.js","webpack://egg-born-module-a-file/./backend/src/service/file.js","webpack://egg-born-module-a-file/./backend/src/services.js","webpack://egg-born-module-a-file/external commonjs2 \"require3\"","webpack://egg-born-module-a-file/external node-commonjs \"fs\"","webpack://egg-born-module-a-file/external node-commonjs \"path\"","webpack://egg-born-module-a-file/webpack/bootstrap","webpack://egg-born-module-a-file/webpack/before-startup","webpack://egg-born-module-a-file/webpack/startup","webpack://egg-born-module-a-file/webpack/after-startup"],"sourcesContent":["const path = require('path');\nconst fs = require('fs');\nconst require3 = require('require3');\nconst sendToWormhole = require3('stream-wormhole');\nconst uuid = require3('uuid');\nconst Jimp = require3('jimp');\nconst bb = require3('bluebird');\nconst pump = require3('pump');\nconst fse = require3('fs-extra');\nconst extend = require3('@zhennann/extend');\nconst base64url = require3('base64url');\nconst FileType = require3('file-type');\n\nconst REGEXP_DATA_URL = /^data:([^;]+);[^,]*base64,(.*)/;\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class File {\n    get modelFile() {\n      return ctx.model.module(moduleInfo.relativeName).file;\n    }\n    get modelFileView() {\n      return ctx.model.module(moduleInfo.relativeName).fileView;\n    }\n\n    async all({ atomClass, options, user }) {\n      // file\n      options.file = 1;\n      // select\n      const items = await ctx.bean.atom.select({\n        atomClass,\n        options,\n        user,\n      });\n      // downloadUrl\n      for (const item of items) {\n        item.i_downloadUrl = this.getDownloadUrl({\n          downloadId: item.i_downloadId,\n          atomId: item.atomId,\n          mode: item.i_mode,\n          fileExt: item.i_fileExt,\n        });\n      }\n      // ok\n      return items;\n    }\n\n    // key,user maybe null\n    async list({ key, options, user }) {\n      // page\n      options.page = ctx.bean.util.page(options.page, false);\n      // where\n      options.where = options.where || {};\n      // check right: atom.read or user's files\n      const atomId = key && key.atomId;\n      if (atomId) {\n        if (user && user.id) {\n          const res = await ctx.bean.atom.checkRightRead({\n            atom: { id: atomId },\n            user,\n            checkFlow: true,\n          });\n          if (!res) ctx.throw(403);\n        }\n        options.where.atomId = atomId; // add where\n      } else {\n        if (user && user.id) {\n          options.where.userId = user.id; // add where\n        }\n      }\n      // _options\n      const _options = {};\n      // where\n      _options.where = options.where || {};\n      // orders\n      _options.orders = options.orders;\n      // page\n      if (options.page.size !== 0) {\n        _options.limit = options.page.size;\n        _options.offset = options.page.index;\n      }\n      // select\n      const items = await this.modelFileView.select(_options);\n      for (const item of items) {\n        item.downloadUrl = this.getDownloadUrl(item);\n      }\n      return items;\n    }\n\n    async attachments({ key, options, user }) {\n      options = options || {};\n      // filter drafts\n      options.where = extend(true, options.where, {\n        mode: 2,\n        attachment: 1,\n      });\n      if (!options.orders) {\n        options.orders = [['realName', 'asc']];\n      }\n      // list\n      return await this.list({ key, options, user });\n    }\n\n    async delete({ downloadId, fileId, user }) {\n      // file\n      const file = await this.getFile({ downloadId, fileId });\n      if (!file) ctx.throw(404);\n      // check right\n      if (user && user.id) {\n        await this.fileUpdateCheck({ file, user });\n      }\n      // delete\n      await this.modelFile.delete({ id: file.id });\n      // attachmentCount\n      if (file.atomId && file.attachment) {\n        await ctx.bean.atom.attachment({ key: { atomId: file.atomId }, atom: { attachment: -1 } });\n      }\n    }\n\n    async update({ fileId, data, user }) {\n      // check\n      if (user && user.id) {\n        // file\n        const file = await this.modelFile.get({ id: fileId });\n        // check right\n        await this.fileUpdateCheck({ file, user });\n      }\n      // update\n      await this.modelFile.update({\n        id: fileId,\n        ...data,\n      });\n    }\n\n    async upload({ user }) {\n      const stream = await ctx.getFileStream();\n      try {\n        const meta = {\n          filename: stream.filename,\n          encoding: stream.encoding,\n          mime: stream.mime,\n          fields: stream.fields,\n        };\n        return await this._upload({ fileContent: stream, meta, user });\n      } catch (e) {\n        await sendToWormhole(stream);\n        throw e;\n      }\n    }\n\n    async uploadDataUrl({ data, user }) {\n      const dataUrl = data.dataUrl || '';\n      const matches = dataUrl.match(REGEXP_DATA_URL);\n      if (!matches) return null;\n      // info\n      const mime = matches[1];\n      const contentBase64 = matches[2];\n      let ext = mime.split('/')[1];\n      if (ext.indexOf('svg') > -1) {\n        ext = 'svg';\n      }\n      const filename = `${data.title || '_none_'}.${ext}`;\n      const encoding = data.encoding || '7bit';\n      // content\n      const fileContent = base64url.toBuffer(contentBase64);\n      // console.log('----fileContent: ', typeof fileContent);\n      // meta\n      const meta = {\n        filename,\n        encoding,\n        mime,\n        fields: {\n          mode: data.mode,\n          atomId: data.atomId,\n          attachment: data.attachment,\n          flag: data.flag,\n        },\n      };\n      return await this._upload({ fileContent, meta, user });\n    }\n\n    async uploadByLocalFile({ pathFile, meta, user }) {\n      if (!meta) meta = {};\n      if (!meta.fields) meta.fields = {};\n      // mode\n      if (!meta.fields.mode) {\n        meta.fields.mode = 2; // file\n      }\n      // filename\n      if (!meta.filename) {\n        meta.filename = path.basename(pathFile);\n      }\n      // encoding\n      if (!meta.encoding) {\n        meta.encoding = '7bit';\n      }\n      // content\n      const fileContent = await fse.readFile(pathFile);\n      // mime\n      if (!meta.mime) {\n        const res = await FileType.fileTypeFromBuffer(fileContent);\n        if (res) {\n          meta.mime = res.mime;\n        }\n      }\n      // upload\n      return await this._upload({\n        fileContent,\n        meta,\n        user,\n      });\n    }\n\n    async _upload({ fileContent, meta, user }) {\n      // info\n      const fileInfo = path.parse(meta.filename);\n      if (fileInfo.name === '_none_') {\n        fileInfo.name = '';\n      }\n      if (fileInfo.ext) fileInfo.ext = fileInfo.ext.toLowerCase();\n      const encoding = meta.encoding;\n      const mime = meta.mime;\n      const fields = meta.fields;\n      const mode = parseInt(fields.mode || 2);\n      const atomId = parseInt(fields.atomId || 0);\n      const attachment = parseInt(fields.attachment || 0);\n      const flag = fields.flag || '';\n      let imgWidth = 0;\n      let imgHeight = 0;\n\n      // jpeg->jpg\n      if (fileInfo.ext === '.jpeg') fileInfo.ext = '.jpg';\n\n      // dest\n      const downloadId = uuid.v4().replace(/-/g, '');\n      const _filePath = `file/${mode === 1 ? 'image' : mode === 2 ? 'file' : 'audio'}/${ctx.bean.util.today()}`;\n      const _fileName = uuid.v4().replace(/-/g, '');\n      const destDir = await ctx.bean.base.getPath(_filePath, true);\n      const destFile = path.join(destDir, `${_fileName}${fileInfo.ext}`);\n\n      // write\n      if (mode === 1) {\n        if (!this._isSupportedImageTypes(fileInfo.ext)) {\n          await this._outputFileContent({ destFile, fileContent });\n        } else {\n          const size = await this._outputImageContent({ destFile, fileContent, fields, fileInfo });\n          imgWidth = size.width;\n          imgHeight = size.height;\n        }\n      } else if (mode === 2 || mode === 3) {\n        // check right only for file\n        if (mode === 2) {\n          await this._checkRightWrite({ atomId, user });\n        }\n        // file\n        await this._outputFileContent({ destFile, fileContent });\n      }\n\n      // fileSize\n      const stat = await fse.stat(destFile);\n      const fileSize = stat.size;\n\n      // save\n      const res = await this.modelFile.insert({\n        userId: user ? user.id : 0,\n        downloadId,\n        atomId,\n        mode,\n        fileSize,\n        width: imgWidth,\n        height: imgHeight,\n        filePath: _filePath,\n        fileName: _fileName,\n        realName: fileInfo.name,\n        fileExt: fileInfo.ext,\n        encoding,\n        mime,\n        attachment,\n        flag,\n      });\n      const fileId = res.insertId;\n\n      // attachmentCount\n      if (atomId && attachment) {\n        await ctx.bean.atom.attachment({ key: { atomId }, atom: { attachment: 1 }, user });\n      }\n\n      // ok\n      const downloadUrl = this.getDownloadUrl({ downloadId, mode, fileExt: fileInfo.ext });\n      return {\n        fileId,\n        realName: fileInfo.name,\n        downloadId,\n        downloadUrl,\n      };\n    }\n\n    async download({ downloadId, atomId, width, height, user }) {\n      // downloadId\n      if (!downloadId) ctx.throw(404);\n      const extPos = downloadId.indexOf('.');\n      if (extPos > -1) downloadId = downloadId.substr(0, extPos);\n\n      // get file\n      const file = await this._getFileByDownloadId({ downloadId, atomId });\n      if (!file) ctx.throw(404);\n\n      // pre\n      let fileName = file.fileName;\n      if (file.mode === 1) {\n        if (this._isSupportedImageTypes(file.fileExt)) {\n          // adjust image\n          fileName = await this._adjustImage(file, width, height);\n        }\n      } else if (file.mode === 2) {\n        // check right\n        await this.fileDownloadCheck({ file, user });\n      } else if (file.mode === 3) {\n        // do nothing\n      }\n\n      // forward url\n      const forwardUrl = ctx.bean.base.getForwardUrl(`${file.filePath}/${fileName}${file.fileExt}`);\n\n      // send\n      if (ctx.app.meta.isTest || ctx.app.meta.isLocal) {\n        // redirect\n        ctx.redirect(forwardUrl);\n      } else {\n        // redirect nginx\n        // ctx.set('content-type', file.mime);\n        ctx.set('content-transfer-encoding', file.encoding);\n        ctx.set(\n          'content-disposition',\n          `attachment; filename*=UTF-8''${encodeURIComponent(file.realName)}${file.fileExt}`\n        );\n        ctx.set('X-Accel-Redirect', forwardUrl);\n        // ctx.success();\n        ctx.response.status = 200;\n        ctx.response.type = file.mime;\n      }\n    }\n\n    async getFile({ downloadId, fileId }) {\n      let file;\n      if (downloadId) {\n        const extPos = downloadId.indexOf('.');\n        if (extPos > -1) downloadId = downloadId.substr(0, extPos);\n        file = await this.modelFile.get({ downloadId });\n      } else if (fileId) {\n        file = await this.modelFile.get({ id: fileId });\n      }\n      return file;\n    }\n\n    // inner invoke\n    async fileInfo({ downloadId, fileId }) {\n      const file = await this.getFile({ downloadId, fileId });\n      if (!file) ctx.throw(404);\n\n      // absolutePath\n      const destDir = await ctx.bean.base.getPath(file.filePath, true);\n      const absolutePath = path.join(destDir, `${file.fileName}${file.fileExt}`);\n      // ok\n      return {\n        file,\n        absolutePath,\n      };\n    }\n\n    async loadBuffer({ downloadId }) {\n      const fileInfo = await this.fileInfo({ downloadId });\n      const buffer = await fse.readFile(fileInfo.absolutePath);\n      return {\n        ...fileInfo,\n        buffer,\n      };\n    }\n\n    async fileUpdateCheck({ file, user }) {\n      if (!user) {\n        // check user\n        await ctx.bean.user.check();\n        user = ctx.state.user.op;\n      }\n      // check\n      const result = await this._fileUpdateCheck({ file, user });\n      if (result) return;\n      ctx.throw(403);\n    }\n\n    async _fileUpdateCheck({ file, user }) {\n      // invoke event\n      return await ctx.bean.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'fileUpdateCheck',\n        data: { file, user },\n        next: async (context, next) => {\n          if (context.result !== undefined) return await next();\n          // not check if !atomId\n          if (file.atomId) {\n            const res = await ctx.bean.atom.checkRightAction({\n              atom: { id: file.atomId },\n              action: 3,\n              stage: 'draft',\n              user,\n              checkFlow: true,\n            });\n            context.result = res && res.atomClosed === 0;\n          } else {\n            // check if self\n            context.result = file.userId === user.id;\n          }\n          // next\n          await next();\n        },\n      });\n    }\n\n    async fileDownloadCheck({ file, user }) {\n      if (!user) {\n        // check user\n        await ctx.bean.user.check();\n        user = ctx.state.user.op;\n      }\n      // check\n      const result = await this._fileDownloadCheck({ file, user });\n      if (result) return;\n      ctx.throw(403);\n    }\n\n    async _fileDownloadCheck({ file, user }) {\n      // invoke event\n      return await ctx.bean.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'fileDownloadCheck',\n        data: { file, user },\n        next: async (context, next) => {\n          if (context.result !== undefined) return await next();\n          // not check if !atomId\n          if (file.atomId) {\n            const res = await ctx.bean.atom.checkRightRead({\n              atom: { id: file.atomId },\n              user,\n              checkFlow: true,\n              disableAuthOpenCheck: true,\n            });\n            context.result = !!res;\n          } else {\n            // check if self\n            context.result = file.userId === user.id;\n          }\n          // next\n          await next();\n        },\n      });\n    }\n\n    _isSupportedImageTypes(fileExt) {\n      return (\n        !['.svg', '.svgz'].includes(fileExt) && ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.gif'].includes(fileExt)\n      );\n    }\n\n    async _adjustImage(file, widthRequire, heightRequire) {\n      widthRequire = widthRequire ? parseInt(widthRequire) : 0;\n      heightRequire = heightRequire ? parseInt(heightRequire) : 0;\n      if (!widthRequire && !heightRequire) return file.fileName;\n\n      // cannot use * in path on windows\n      const fileName = `${file.fileName}-${widthRequire}_${heightRequire}`;\n      const destFile = await ctx.bean.base.getPath(`${file.filePath}/${fileName}${file.fileExt}`, false);\n\n      const bExists = await fse.pathExists(destFile);\n      if (bExists) return fileName;\n\n      const width = widthRequire || parseInt((file.width * heightRequire) / file.height);\n      const height = heightRequire || parseInt((file.height * widthRequire) / file.width);\n\n      const srcFile = await ctx.bean.base.getPath(`${file.filePath}/${file.fileName}${file.fileExt}`, false);\n\n      // image\n      let img = await Jimp.read(srcFile);\n      img = img.resize(width, height);\n      await bb.fromCallback(cb => {\n        img.write(destFile, cb);\n      });\n\n      return fileName;\n    }\n\n    async _getFileByDownloadId({ downloadId, atomId }) {\n      if (atomId) {\n        return await this.modelFile.get({ downloadId, atomId });\n      }\n      // try to get formal\n      const file = await ctx.model.queryOne(\n        `\n          select a.* from aFile a\n            inner join aAtom b on a.atomId=b.id\n              where a.iid=? and a.deleted=0 and a.mode=2 and a.downloadId=? and b.atomStage=1\n        `,\n        [ctx.instance.id, downloadId]\n      );\n      if (file) return file;\n      // no matter what atomId is: maybe ===0 or !==0\n      return await ctx.model.file.get({ downloadId });\n    }\n\n    async _checkRightWrite({ atomId, user }) {\n      // not check if !atomId\n      if (!atomId) return;\n      const res = await ctx.bean.atom.checkRightAction({\n        atom: { id: atomId },\n        action: 3,\n        stage: 'draft',\n        user,\n        checkFlow: true,\n        disableAuthOpenCheck: true,\n      });\n      if (res && res.atomClosed === 0) return;\n      ctx.throw(403);\n    }\n\n    async _outputImageContent({ destFile, fileContent, fields, fileInfo }) {\n      // prepare image content\n      const tmpFile = destFile + fileInfo.ext;\n      await this._outputFileContent({ destFile: tmpFile, fileContent });\n      // image\n      let img = await Jimp.read(tmpFile);\n      // crop\n      if (fields.cropped === 'true') {\n        const cropbox = JSON.parse(fields.cropbox);\n        img = img.crop(parseInt(cropbox.x), parseInt(cropbox.y), parseInt(cropbox.width), parseInt(cropbox.height));\n      }\n      // fixed\n      if (fields.fixed) {\n        const fixed = JSON.parse(fields.fixed);\n        if (fixed.width && fixed.height) {\n          img = img.resize(fixed.width, fixed.height);\n        } else if (fixed.width) {\n          img = img.resize(fixed.width, Jimp.AUTO);\n        } else if (fixed.height) {\n          img = img.resize(Jimp.AUTO, fixed.height);\n        }\n      }\n      // quality\n      if (['.png', '.jpg', '.jpeg'].includes(fileInfo.ext)) {\n        img = img.quality(93);\n      }\n      // save\n      await bb.fromCallback(cb => {\n        img.write(destFile, cb);\n      });\n      // size\n      const width = img.bitmap.width;\n      const height = img.bitmap.height;\n      // delete tmp file\n      await fse.remove(tmpFile);\n      // ready\n      return { width, height };\n    }\n\n    async _outputFileContent({ destFile, fileContent }) {\n      if (Buffer.isBuffer(fileContent)) {\n        // buffer\n        await fse.outputFile(destFile, fileContent);\n      } else {\n        // stream\n        const writeStream = fs.createWriteStream(destFile);\n        await bb.fromCallback(cb => {\n          pump(fileContent, writeStream, cb);\n        });\n      }\n    }\n\n    getDownloadUrl({ downloadId, atomId, mode, fileExt }) {\n      let url = `/api/a/file/file/download/${downloadId}${mode === 1 || mode === 3 ? fileExt : ''}`;\n      if (atomId) {\n        url = `${url}?atomId=${atomId}`;\n      }\n      return ctx.bean.base.getAbsoluteUrl(url);\n    }\n  }\n  return File;\n};\n","module.exports = app => {\n  class Version extends app.meta.BeanBase {\n    async update(options) {\n      if (options.version === 1) {\n        // create table: aFile\n        let sql = `\n          CREATE TABLE aFile (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            downloadId varchar(50) DEFAULT NULL,\n            atomId int(11) DEFAULT '0',\n            mode int(11) DEFAULT '0',\n            fileSize int(11) DEFAULT '0',\n            width int(11) DEFAULT '0',\n            height int(11) DEFAULT '0',\n            filePath varchar(255) DEFAULT NULL,\n            fileName varchar(255) DEFAULT NULL,\n            realName varchar(255) DEFAULT NULL,\n            fileExt varchar(50) DEFAULT NULL,\n            encoding varchar(50) DEFAULT NULL,\n            mime varchar(50) DEFAULT NULL,\n            attachment int(11) DEFAULT '0',\n            flag varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // aViewFile\n        sql = `\n          create view aViewFile as\n            select a.*,b.userName,b.avatar from aFile a\n              left join aUser b on a.userId=b.id\n        `;\n        await this.ctx.model.query(sql);\n      }\n\n      if (options.version === 2) {\n        // aFile: mime\n        const sql = `\n        ALTER TABLE aFile\n          CHANGE COLUMN mime mime varchar(255) DEFAULT NULL\n        `;\n        await this.ctx.model.query(sql);\n      }\n    }\n\n    async init(options) {}\n\n    async test() {}\n  }\n\n  return Version;\n};\n","const versionManager = require('./bean/version.manager.js');\nconst beanFile = require('./bean/bean.file.js');\n\nmodule.exports = app => {\n  const beans = {\n    // version\n    'version.manager': {\n      mode: 'app',\n      bean: versionManager,\n    },\n    // global\n    file: {\n      mode: 'ctx',\n      bean: beanFile,\n      global: true,\n    },\n  };\n  return beans;\n};\n","// eslint-disable-next-line\nmodule.exports = appInfo => {\n  const config = {};\n  return config;\n};\n","// error code should start from 1001\nmodule.exports = {};\n","module.exports = {\n  File: '文件',\n};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = app => {\n  const schemas = {};\n  return schemas;\n};\n","module.exports = app => {\n  class FileController extends app.Controller {\n    async all() {\n      const options = this.ctx.request.body.options;\n      options.page = this.ctx.bean.util.page(options.page);\n      const items = await this.ctx.service.file.all({\n        atomClass: this.ctx.request.body.atomClass,\n        options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.successMore(items, options.page.index, options.page.size);\n    }\n\n    async list() {\n      const options = this.ctx.request.body.options;\n      options.page = this.ctx.bean.util.page(options.page, false);\n      const items = await this.ctx.service.file.list({\n        key: this.ctx.request.body.key,\n        options: this.ctx.request.body.options,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.successMore(items, options.page.index, options.page.size);\n    }\n\n    async update() {\n      const res = await this.ctx.service.file.update({\n        fileId: this.ctx.request.body.fileId,\n        data: this.ctx.request.body.data,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async delete() {\n      const res = await this.ctx.service.file.delete({\n        fileId: this.ctx.request.body.fileId || this.ctx.request.body.data.fileId,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async upload() {\n      const res = await this.service.file.upload({\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async uploadDataUrl() {\n      const res = await this.service.file.uploadDataUrl({\n        data: this.ctx.request.body.data,\n        user: this.ctx.state.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async download() {\n      await this.service.file.download({\n        downloadId: this.ctx.params.downloadId,\n        atomId: parseInt(this.ctx.query.atomId || 0),\n        width: this.ctx.query.width,\n        height: this.ctx.query.height,\n        user: this.ctx.state.user.op,\n      });\n    }\n  }\n  return FileController;\n};\n","const file = require('./controller/file.js');\n\nmodule.exports = app => {\n  const controllers = {\n    file,\n  };\n  return controllers;\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\n\nmodule.exports = app => {\n  // beans\n  const beans = require('./beans.js')(app);\n  // routes\n  const routes = require('./routes.js')(app);\n  // controllers\n  const controllers = require('./controllers.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    beans,\n    routes,\n    controllers,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    meta,\n  };\n};\n","module.exports = app => {\n  const schemas = require('./config/validation/schemas.js')(app);\n  const meta = {\n    base: {\n      atoms: {},\n    },\n    validation: {\n      validators: {},\n      keywords: {},\n      schemas,\n    },\n    event: {\n      declarations: {\n        fileUpdateCheck: 'File Update Check',\n        fileDownloadCheck: 'File Download Check',\n      },\n    },\n  };\n  return meta;\n};\n","module.exports = app => {\n  class File extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aFile', options: { disableDeleted: false } });\n    }\n  }\n  return File;\n};\n","module.exports = app => {\n  class FileView extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aViewFile', options: { disableDeleted: false } });\n    }\n  }\n  return FileView;\n};\n","const file = require('./model/file.js');\nconst fileView = require('./model/fileView.js');\n\nmodule.exports = app => {\n  const models = {\n    file,\n    fileView,\n  };\n  return models;\n};\n","module.exports = app => {\n  const routes = [\n    // file\n    { method: 'post', path: 'file/upload', controller: 'file', meta: { auth: { user: true } } },\n    { method: 'post', path: 'file/uploadDataUrl', controller: 'file', meta: { auth: { user: true } } },\n    { method: 'get', path: 'file/download/:downloadId', controller: 'file', action: 'download' },\n    { method: 'post', path: 'file/list', controller: 'file' },\n    { method: 'post', path: 'file/update', controller: 'file' },\n    { method: 'post', path: 'file/delete', controller: 'file', middlewares: 'transaction' },\n    { method: 'post', path: 'file/all', controller: 'file' },\n  ];\n  return routes;\n};\n","module.exports = app => {\n  // const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class File extends app.Service {\n    async all({ atomClass, options, user }) {\n      return await this.ctx.bean.file.all({ atomClass, options, user });\n    }\n\n    // where adjusted by controller\n    async list({ key, options, user }) {\n      return await this.ctx.bean.file.list({ key, options, user });\n    }\n\n    async delete({ fileId, user }) {\n      return await this.ctx.bean.file.delete({ fileId, user });\n    }\n\n    async update({ fileId, data, user }) {\n      return await this.ctx.bean.file.update({ fileId, data, user });\n    }\n\n    async upload({ user }) {\n      return await this.ctx.bean.file.upload({ user });\n    }\n\n    async uploadDataUrl({ data, user }) {\n      return await this.ctx.bean.file.uploadDataUrl({ data, user });\n    }\n\n    async download({ downloadId, atomId, width, height, user }) {\n      return await this.ctx.bean.file.download({ downloadId, atomId, width, height, user });\n    }\n\n    // inner invoke\n    async fileInfo({ downloadId }) {\n      return await this.ctx.bean.file.fileInfo({ downloadId });\n    }\n\n    async fileUpdateCheck({ file, user }) {\n      return await this.ctx.bean.file.fileUpdateCheck({ file, user });\n    }\n\n    async fileDownloadCheck({ file, user }) {\n      return await this.ctx.bean.file.fileDownloadCheck({ file, user });\n    }\n  }\n\n  return File;\n};\n","const file = require('./service/file.js');\n\nmodule.exports = app => {\n  const services = {\n    file,\n  };\n  return services;\n};\n","module.exports = require(\"require3\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(421);\n",""],"names":[],"sourceRoot":""}