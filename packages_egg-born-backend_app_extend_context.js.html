<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>packages/egg-born-backend/app/extend/context.js - CabloyJS API</title>
    
    
    
    
    
    <meta property="og:title" content="CabloyJS API"/>
    <meta property="og:type" content=""/>
    <meta property="og:image" content=""/>
    <meta property="og:site_name" content="CabloyJS API"/>
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="search" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://cabloy.com" target="_blank" class="menu-item" id="documentations_link" >Documentations</a></h2><h2><a href="https://community.cabloy.com" target="_blank" class="menu-item" id="community_link" >Community</a></h2><h3>Modules</h3><ul><li><a href="module-a-base_front_config.html">a-base/front/config</a></li><li><a href="module-a-base_front_mixins.html">a-base/front/mixins</a></li><li><a href="module-a-base_front_mixins_ebActionBase.html">a-base/front/mixins/ebActionBase</a></li><li><a href="module-a-base_front_mixins_ebAtomClasses.html">a-base/front/mixins/ebAtomClasses</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-a-base_front_mixins_ebAtomClasses.html#getAtomClass#~getAtomClass">getAtomClass</a></li></ul></li><li><a href="module-a-basefront_front_pages_base_alert.html">a-basefront/front/pages/base/alert</a></li><li><a href="module-a-components_front_components_eb-stats-color.html">a-components/front/components/eb-stats-color</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-a-components_front_components_eb-stats-color.html#onAdjustValue#~onAdjustValue">onAdjustValue</a></li><li data-type='method' style='display: none;'><a href="module-a-components_front_components_eb-stats-color.html#onChange#~onChange">onChange</a></li></ul></li><li><a href="module-egg-born-front_base_config.html">egg-born-front/base/config</a></li><li><a href="module-project_build_config.html">project/build/config</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">packages/egg-born-backend/app/extend/context.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const http = require('http');
const compose = require('koa-compose');
const onFinished = require('on-finished');
const statuses = require('statuses');
const isJSON = require('koa-is-json');
const Stream = require('stream');
const is = require('is-type-of');
const raw = require('raw-body');
const inflate = require('inflation');
const mparse = require('egg-born-mparse').default;

const MODULE = Symbol.for('Context#__module');
const DATABASE = Symbol.for('Context#__database');
const DATABASEMETA = Symbol.for('Context#__databasemeta');
const INNERACCESS = Symbol.for('Context#__inneraccess');
const SUBDOMAIN = Symbol.for('Context#__subdomain');
const CTXCALLER = Symbol.for('Context#__ctxcaller');
const TAILCALLBACKS = Symbol.for('Context#__tailcallbacks');

class DbTransaction {
  constructor(ctx) {
    this._ctx = ctx;
    this._transactionCounter = 0;
    this._connection = null;
  }
  get inTransaction() {
    return this._transactionCounter > 0;
  }
  get connection() {
    return this._connection;
  }
  set connection(value) {
    this._connection = value;
  }
  async begin(fn) {
    let res;
    const db = getDbOriginal(this._ctx);
    try {
      if (++this._transactionCounter === 1) {
        this._connection = await db.beginTransaction();
      }
    } catch (err) {
      this._transactionCounter--;
      throw err;
    }
    try {
      res = await fn();
    } catch (err) {
      if (--this._transactionCounter === 0) {
        await this._connection.rollback();
        this._connection = null;
      }
      throw err;
    }
    try {
      if (--this._transactionCounter === 0) {
        await this._connection.commit();
        this._connection = null;
      }
    } catch (err) {
      await this._connection.rollback();
      this._connection = null;
      throw err;
    }
    return res;
  }
}

module.exports = {
  get module() {
    if (this[MODULE] === undefined) {
      const info = mparse.parseInfo(mparse.parseName(this.req.mockUrl || this.req.url));
      this[MODULE] = info ? this.app.meta.modules[info.relativeName] : null;
    }
    return this[MODULE];
  },
  get db() {
    if (!this[DATABASE]) {
      this[DATABASE] = createDatabase(this);
    }
    return this[DATABASE];
  },
  set db(value) {
    this[DATABASE] = value;
  },
  get dbMeta() {
    if (!this[DATABASEMETA]) {
      this[DATABASEMETA] = {
        master: true,
        transaction: new DbTransaction(this),
      };
    }
    return this[DATABASEMETA];
  },
  set dbMeta(metaCaller) {
    // transaction
    if (metaCaller.transaction.inTransaction) {
      this.dbMeta.master = false; // false only on metaCaller.transaction=true
      this.dbMeta.transaction = metaCaller.transaction;
    }
  },
  get transaction() {
    return this.dbMeta.transaction;
  },
  get innerAccess() {
    return this[INNERACCESS];
  },
  set innerAccess(value) {
    this[INNERACCESS] = value;
  },
  get subdomain() {
    return typeof this[SUBDOMAIN] === 'undefined' ? this.subdomains.join('.') : this[SUBDOMAIN];
  },
  set subdomain(value) {
    this[SUBDOMAIN] = value;
  },
  get ctxCaller() {
    return this[CTXCALLER];
  },
  set ctxCaller(value) {
    // ctxCaller
    this[CTXCALLER] = value;
    // innerAccess
    this.innerAccess = true;
    // transaction
    this.dbMeta = value.dbMeta;
  },
  get cache() {
    return this.bean.cache;
  },
  tail(cb) {
    if (this.ctxCaller) {
      this.ctxCaller.tail(cb);
    } else {
      this.tailCallbacks.push(cb);
    }
  },
  async tailDone() {
    while (true) {
      const cb = this.tailCallbacks.shift();
      if (!cb) break;
      try {
        await cb();
      } catch (err) {
        this.app.logger.error(err);
      }
    }
  },
  get tailCallbacks() {
    if (!this[TAILCALLBACKS]) {
      this[TAILCALLBACKS] = [];
    }
    return this[TAILCALLBACKS];
  },

  async executeBean({ locale, subdomain, beanModule, beanFullName, context, fn, transaction }) {
    return await this.app.meta.util.executeBean({
      locale: locale === undefined ? this.locale : locale,
      subdomain: subdomain === undefined ? this.subdomain : subdomain,
      context,
      beanModule,
      beanFullName,
      transaction,
      fn,
      ctxCaller: this,
    });
  },

  // * deprecated
  performActionInBackground(options) {
    // inherit subdomain, cookies such as locale
    const ctx = this;
    ctx.runInBackground(() => {
      // performAction
      return ctx.performAction(options);
    });
  },

  /**
   * perform action of this or that module
   * @param  {string} options.method method
   * @param  {string} options.url    url
   * @param  {json} options.data   data(optional)
   * @return {promise}                response.body.data or throw error
   */
  performAction({ innerAccess, subdomain, method, url, query, params, headers, body }) {
    return new Promise((resolve, reject) => {
      const handleRequest = appCallback.call(this.app);
      const request = createRequest(
        {
          method,
          url: this.app.meta.util.combineFetchPath(this.module &amp;&amp; this.module.info, url),
        },
        this
      );
      const response = new http.ServerResponse(request);
      handleRequest(this, innerAccess, subdomain, request, response, resolve, reject, query, params, headers, body);
    });
  },

  getVal(name) {
    return (
      (this.params &amp;&amp; this.params[name]) ||
      (this.query &amp;&amp; this.query[name]) ||
      (this.request.body &amp;&amp; this.request.body[name])
    );
  },

  getInt(name) {
    return parseInt(this.getVal(name));
  },

  getFloat(name) {
    return parseFloat(this.getVal(name));
  },

  getStr(name) {
    const v = this.getVal(name);
    return (v &amp;&amp; v.toString()) || '';
  },

  getSafeStr(name) {
    const v = this.getStr(name);
    return v.replace(/'/gi, "''");
  },

  successMore(list, index, size) {
    this.success({ list, index: index + list.length, finished: size === -1 || size === 0 || list.length &lt; size });
  },

  async getPayload(options) {
    return await raw(inflate(this.req), options);
  },
};

function appCallback() {
  const fn = compose(this.middleware);
  const self = this;

  if (!this.listeners('error').length) this.on('error', this.onerror);

  return function handleRequest(
    ctxCaller,
    innerAccess,
    subdomain,
    req,
    res,
    resolve,
    reject,
    query,
    params,
    headers,
    body
  ) {
    res.statusCode = 404;
    const ctx = self.createContext(req, res);
    onFinished(res, ctx.onerror);

    // subdomain
    ctx.subdomain = typeof subdomain === 'undefined' ? ctxCaller.subdomain : subdomain;

    // query params body
    if (query) ctx.query = query;
    if (params) ctx.params = params;
    ctx.request.body = body || null; // not undefined

    // headers
    if (headers) Object.assign(ctx.headers, headers);

    // multipart
    ctx.multipart = function (options) {
      return ctxCaller.multipart(options);
    };

    // cookies
    delegateCookies(ctx, ctxCaller);

    // ctxCaller
    ctx.ctxCaller = ctxCaller;

    // innerAccess
    if (innerAccess !== undefined) ctx.innerAccess = innerAccess;

    // call
    fn(ctx)
      .then(function handleResponse() {
        respond.call(ctx);
        if (ctx.status === 200) {
          if (!ctx.body || ctx.body.code === undefined) {
            // not check code, e.g. text/xml
            resolve(ctx.body);
          } else {
            if (ctx.body.code === 0) {
              resolve(ctx.body.data);
            } else {
              const error = ctx.createError(ctx.body);
              reject(error);
            }
          }
        } else {
          const error = ctx.createError({
            code: ctx.status,
            message: ctx.message || ctx.body,
          });
          reject(error);
        }
      })
      .catch(err => {
        const error = ctx.createError(err);
        ctx.onerror(error);
        reject(error);
      });
  };
}

function respond() {
  // allow bypassing koa
  if (this.respond === false) return;

  const res = this.res;
  if (res.headersSent || !this.writable) return;

  let body = this.body;
  const code = this.status;

  // ignore body
  if (statuses.empty[code]) {
    // strip headers
    this.body = null;
    return res.end();
  }

  if (this.method === 'HEAD') {
    if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body));
    return res.end();
  }

  // status body
  if (body == null) {
    this.type = 'text';
    body = this.message || String(code);
    this.length = Buffer.byteLength(body);
    return res.end(body);
  }

  // responses
  if (Buffer.isBuffer(body)) return res.end(body);
  if (typeof body === 'string') return res.end(body);
  if (body instanceof Stream) return body.pipe(res);

  // body: json
  body = JSON.stringify(body);
  this.length = Buffer.byteLength(body);
  res.end(body);
}

function delegateCookies(ctx, ctxCaller) {
  const _cookies = ctx.cookies;
  Object.defineProperty(ctx, 'cookies', {
    get() {
      return ctxCaller.cookies || _cookies;
    },
  });
}

function createRequest({ method, url }, ctxCaller) {
  // _req
  const _req = ctxCaller.request;
  // req
  const req = new http.IncomingMessage();
  req.headers = _req.headers;
  req.host = _req.host;
  req.hostname = _req.hostname;
  req.protocol = _req.protocol;
  req.secure = _req.secure;
  req.method = method.toUpperCase();
  req.url = url;
  // path,
  req.socket = {
    remoteAddress: _req.socket.remoteAddress,
    remotePort: _req.socket.remotePort,
  };
  return req;
}

function getDbOriginal(ctx) {
  return ctx.app.mysql.__ebdb_test || ctx.app.mysql.get('__ebdb');
}

function createDatabase(ctx) {
  const db = getDbOriginal(ctx);
  return new Proxy(db, {
    get(target, prop) {
      const value = target[prop];
      if (!is.function(value)) return value;
      if (value.name !== 'createPromise') return value;
      // check if use transaction
      if (!ctx.dbMeta.transaction.inTransaction) return value;
      return function (...args) {
        return ctx.dbMeta.transaction.connection[prop].apply(ctx.dbMeta.transaction.connection, args);
      };
    },
  });
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Mar 02 2022 15:06:15 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/collapse.js"></script>


<script src="scripts/search.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?702a5fbeaa29235d5d07e5233d8a591b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</body>
</html>
